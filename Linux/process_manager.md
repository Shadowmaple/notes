# 进程管理

# 进程

程序（program）：一个二进制文件，放置在存储媒介（如硬盘、光盘、软盘、磁带等）中，以物理文件的形式存在。

进程（process）：运行中的程序。程序被触发后，执行者的**权限与属性**、程序的代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个 PID。

进程拥有执行者的权限，由这个进程衍生出来的其它子进程在一般状态下，也会沿用这个进程的相关权限。

子进程拥有PID和PPID（Parent PID）。

遇到的问题：有时将一个进程关闭后，发现过一阵子它又产生了，并且其PID还不一样。这是因为它是子进程，只要有父进程存在，那么当杀掉其子进程后，父进程就会主动再产生一个。所以要擒贼先擒王，杀掉那个父进程。

fork-and-exec：程序调用流程

Linux 的程序调用通常为 fork-and-exec 流程。

进程都会借由父进程以复制（fork）的方式产生一个一模一样的临时进程（但具有PPID且PID不一样），然后被复制出来的临时进程再以 exec 的方式来执行实际要执行的进程，最终称为一个子进程。

服务（daemon）：常驻在内存中的进程。在后台启动并一直持续不断地运行。

一般 daemon 类型的进程都会在文件名后加上 d，以便简单地判断该进程是否为daemon，如 crond，atd

每个进程可能是独立的，亦可能有依赖性，只要到独立的进程中，删除有问题的那个进程，他就会被系统删除掉。

所以 Linux 几乎不会存在宕机的问题。因为它可以在任何时候，将某个被困住的进程杀掉，然后再重新执行该进程而不用重新启动。若在 Linux 以命令行界面登录，在屏幕中显示错误信息后就挂了，动都不能动，怎么办？这个时候就可以动用系统默认的七个终端界面（tty），随意切换到任意一个终端界面，用 `ps -aux`找出错误的进程，然后 `kill`一下就ok了。

>   Linux系统默认提供六个命令行界面，和一个图形界面

# 任务管理

该任务管理（job control）是用在 bash 环境下的，即当我们登录系统获取 bash shell 之后，在单一终端下同时执行多个任务的操作管理。

执行任务管理的操作中，其实每个任务都是目前 bash 的子进程，即彼此之间是由相关性的，我们无法用任务管理的方式由 tty1 的环境去管理 tty2 的bash。

执行 bash shell 的任务管理的限制：

+   shell 只管理自己的shell 所触发的任务的进程
+   前台：可以控制与执行命令的环境
+   后台：可以自动执行的任务，无法使用 ctrl+c 来终止它
+   后台中执行的进程不能等待 terminal 或 shell 的输入

