## 集群内部

broker是集群的成员，代表每一个独立部署的实例，支持横向扩展

控制器





## 复制

每个分区有多个副本，每个broker可以保存千百个不同主题和分区的副本

副本类型：

1. 首领副本。每个分区都有一个首领副本。为了保证一致性，所有生产者请求和消费者请求都会经过
   这个副本。
2. 跟随者副本。首领以外的副本都是跟随者副本，**不处理来自客户端的请求**，唯一的任
   务就是从首领那里复制消息，保持与首领一致的状态。如果首领发生崩溃，其中的一个
   跟随者会被提升为新首领

跟随者副本与首领副本的同步与否看偏移量，若偏移量不同，则为不同步的副本，不同步的副本无法被选举为新首领。

复制过程：

1. 跟随者副本会与客户端一样向首领副本发起请求，先请求3个消息
2. 跟随者副本接收到3个消息后更新本地数据与偏移量，并接着请求第4个消息
3. 首领副本接收到第4个请求就知道前面3个已经接收到了。通过查看请求的最新偏移量，首领副本能够得知跟随者副本的复制进度。

除了当前首领之外，每个分区都有一个首选首领——创建主题时选定的首领就是分区的首选首领。

> 之所以把它叫作首选首领，是因为在创建分区时，需要在 broker 之间均衡首领（后面会介绍在 broker 间分布副本和首领的算法）。因此，我们希望首选首领在成为真正的首领时，broker 间的负载最终会得到均衡。默认情况下，Kafka 的 auto.leader.rebalance.enable 被设为 true，它会检查首选首领是不是当前首领，如果不是，并且该副本是同步的，那么就会触发首领选举，让首选首领成为当前首领

在分区的副本清单中，默认第一个指定的副本就是首选首领



## 通信

kafka定义了一个基于TCP的二进制协议，指定了消息的格式、响应策略（成功、失败）。

broker处理客户端的请求是FIFO，即消息队列，保证了顺序保存的有序性。
请求消息的标准消息头：
- Request type（也就是 API key）- Request version（broker 可以处理不同版本的客户端请求，并根据客户端版本作出不同  的响应）- Correlation ID——一个具有唯一性的数字，用于标识请求消息，同时也会出现在响应消  息和错误日志里（用于诊断问题）- Client ID——用于标识发送请求的客户端
请求类型：
- 生产请求- 消息读取请求：消费者和跟随者副本读取消息发送的请求- 元数据请求：包含了客户端感兴趣的Topic列表。服务器端的响应消息里指明了这些Topic所包含的分区、每个分区的副本、每个分区副本的首领。元数据请求可以发送给任意一个 broker，因为所有 broker 都缓存了这些信息。- 其它请求


生产请求和获取请求都必须发送给分区的首领副本。如果 broker 收到一个针对特定分区的请求，而该分区的首领在另一个 broker 上，那么发送请求的客户端会收到一个“非分区首领”的错误响应。
Kafka 客户端要自己负责把生产请求和获取请求发送到正确的broker 上，因此刚建立连接、或收到“非分区首领”的错误响应时，需要发起“元数据请求”。（客户端也可以通过配置每隔一段时间更新一次元数据）


处理请求的过程：
1. broker在每个监听的端口上运行一个`Acceptor`线程2. 当接收到连接时，会建立一个连接，并交给`Processor`线程处理3. `Processor`线程负责从客户端获取请求消息，并放进请求队列4. IO 线程从请求队列接收到请求消息后，会进行处理。处理后的响应消息会放进响应队列中5. `Processor`线程从响应队列获取响应消息，发送给客户端。
注：`Processor`线程的数量可以配置


**生产请求**
生产者向kafka发送消息时，通过 acks 配置指定要多少个 broker 确认才可以认为一个消息写入是成功的。
- acks=1：只要首领收到消息就认为写入成功- acks=all：所有副本同步完消息才认为写入成功- acks=0：只要生产者发送消息就算成功，不需要等待broker的响应
包含首领副本的 broker 在收到生产请求时，会对请求做一些验证：
1. 发送数据的用户是否有主题写入权限？2. 请求里包含的 acks 值是否有效（只允许出现 0、1 或 all）？3. 如果 acks=all，是否有足够多的同步副本保证消息已经被安全写入？（可以对broker 进行配置，如果同步副本的数量不足，broker 可以拒绝处理新消息。）
在消息被写入分区的首领之后，broker 开始检查 acks 配置参数——如果 acks 被设为 0 或 1，那么 broker 立即返回响应；如果 acks 被设为 all，那么请求会被保存在一个叫炼狱的缓冲区里，直到首领发现所有跟随者副本都复制了消息，响应才会被返回给客户端。
