# 字符集与比较规则

1.  Mysql 基本包含所有字符集

2.  GB2312和GBK是汉字字符集，占2个字节，GBK涵盖GB2312，是升级版

3.  Mysql 中的 utf8 字符集每个字符占3个字节，是阉割版的utf8字符集，真正的utf8是Mysql中的 utf8mb4，占四个字节

4.  查看字符集：

    ```sql
    show character set [like 'utf%']
    show charset [like 'utf%']
    ```

5.  比较规则包含有是否区分大小写、是否区分重音等，每个字符可有多个比较规则，且有一个默认的比较规则

6.  比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中

7.  查看比较规则：`show collation like 'utf8%'`

8.  字符集和比较规则有服务器级、数据库级、表级和列级四个级别，均可单独设置`character set [字符集]`，`collation set [比较规则]`

9.  从客户端发送请求时的字符集转换：

    -   客户端使用操作系统字符集编码，服务器对接收的字符串采用 `character_set_client` 代表的字符集进行解码，再使用`character_set_connection`字符集编码
    -   采用`character_set_connection`进行解码，再按照具体的列的字符集进行编码。若两者的字符集相同，则无需进行字符集的转换
    -   将从某个列获取到的字节串从该列使用的字符集转换为`character_set_results`代表的字符集后发送到客户端
    -   客户端使用操作系统的字符集进行解析

10.  最好统一设置`character_set_client`、`character_set_connection`和`character_set_results`这三个系统变量的值为同一个字符集：`set names utf8`



# InnoDB的记录格式

1.  **页**是InnoDB采用的磁盘与内存交互的基本单位，一般为16kb

2.  行格式有 Compact、Redundant、Dynamic、Compressed 四种。Redundant是Mysql5.0之前的老格式，Dynamic是Mysql 5.7之后的默认行格式

3.  查看、指定和修改行格式的语法如下：

    ```sql
    show variables like '%row_format';
    create table 表名 (列的信息) row_format=行格式名称
    alter table 表名 row_format=行格式名称
    ```

4.  Compact 行格式主要分为四个部分：变长字段长度列表、NULL值列表、记录头信息、记录的真实数据。

5.  Redundant行格式主要分为三个部分：字段长度偏移列表、记录头信息、记录的真实数据。

6.  变长字段长度列表。对列中的变长类型（varchar、varbinary、text、blob）字段的实际长度，按列顺序逆序排放。

7.  每个变长字段存储所占空间为1或2个字节。仅当该可变字段允许存储的**最大字节数**超过255，并且真实存储的字节数超过127字节，使用2个字节，否则使用1个字节存储。

8.  变长字符集（如utf8、gbk）下的定长类型（如char）的长度也会被纳入变长字段长度列表中。

9.  变长字段长度列表中只存储值为 **非NULL** 的列内容占用的长度，值为 NULL 的列的长度是不储存的

10.  NULL值列表仅存储允许为NULL的字段，逆序排列。每个字段占一位，仅有0和1。值为NULL时为1，非NULL时为0。实际按照整数个字节进行存储，不满一个字节（8位）时，前面自动用0补满。

11.  记录的真实数据除了自定义的列以外，还包含有隐藏列：`row_id`（作为主键的唯一标识id，占6字节）、`transaction_id`（事务id，占6字节）、`roll_pointer`（回滚指针，占7字节）。其中`row_id`只有当未设置主键且未设置Unique键时才会自动添加。

12.  Redundant行格式的字段长度偏移列表。所有列都会存长度信息，按照字段的偏移量来存长度。对NULL值处理时，将列对应的偏移量值的第一个比特位作为是否为NULL的依据，如果为1则是NULL，否则非NULL

13.  一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节（不算Text、Blob类型的字段）

14.  行溢出数据。数据量超过16kb则会出现行溢出，本页中只保留前`768`个字节和20个字节的溢出页面地址，剩下数据分散存储到其他页

15.  不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出

16.  相较Compact，Dynamic行格式则是将真实数据的所有字节都存储到其它页中，只在本页保留页地址；Compressed行格式在Dynamic的基础上对页采用压缩算法进行压缩

# InnoDB索引页结构

1.  页有各种不同的类型，用于存放数据的页称为索引页
2.  索引页分为7个部分：`file header`，`page header`，`Infimum + Supremum`，`User Records`，`Free Space`，`Page Directory`，`File Trailer`
3.  记录的记录头信息中，`delete_mask`表示是否删除，1为已删除。记录删除后被组成一个“垃圾链表”，所占用的空间可被重用
4.  每页会事先插入2条虚拟记录，表示最小记录和最大记录，存储在`Infimum + Supremum`部分中
5.  记录的记录头信息中，`next_record`属性表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。从而使页中的所有记录串联成一个`单链表`。
6.  规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）  
7.  `InnoDB`会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中，所以在一个页中根据主键查找记录是非常快的，分为两步：
    +   通过二分法确定该记录所在的槽
    +   通过记录的`next_record`属性遍历该槽所在的组中的各个记录
8.  每个组最后一条记录的头信息的`n_owned`记录该组的记录数，每个分组中的记录条数规定：对于最小记录所在的分组只能有**1**条记录，最大记录所在的分组拥有的记录条数只能是 **1~8** 条，剩下的分组中记录的条数范围只能在是 **4~8** 条
9.  `File Header`部分记录本页的信息，且每个数据页的`File Header`部分都有上一个和下一个页的编号，所以所有的数据页会组成一个`双链表`。该部分各类型的页都通用。
10.  数据页结构中的文件尾部 `File Trailer`， 校验同步是否成功的用途。有校验和、日志序列位置。该部分各类型的页都通用。

|         名称         |       中文名       | 占用空间大小 |         简单描述         |
| :------------------: | :----------------: | :----------: | :----------------------: |
|    `File Header`     |      文件头部      |   `38`字节   |     页的一些通用信息     |
|    `Page Header`     |      页面头部      |   `56`字节   |   数据页专有的一些信息   |
| `Infimum + Supremum` | 最小记录和最大记录 |   `26`字节   |     两个虚拟的行记录     |
|    `User Records`    |      用户记录      |    不确定    |   实际存储的行记录内容   |
|     `Free Space`     |      空闲空间      |    不确定    |    页中尚未使用的空间    |
|   `Page Directory`   |      页面目录      |    不确定    | 页中的某些记录的相对位置 |
|    `File Trailer`    |      文件尾部      |   `8`字节    |      校验页是否完整      |

# B+树索引

1.  数据页中的记录按照主键大小顺序组成一个**单链表**，页与页之间按索引值从小到大组成**双向链表**，下一页的记录的索引值必大于上一页。
2.  当进行插入删除等操作时，不同页之间记录顺序需要调整，该过程称为**页分裂**
3.  对每个页建立索引目录，一页即一条记录，仅包含**主键值和页号**，这种记录称为**目录项记录**，在记录头信息的`record_type`属性被记为1（0为普通记录，2、3为最小和最大记录）
4.  目录项记录储存在一页中，每条目录项指向用户记录的页。多个目录页又形成索引，目录。如此，多个层级，形成一棵B+树
5.  用户记录的页都在B+树的叶子节点上，非叶子节点都是目录项记录页。最底层称为第0层，一般不会超过4层。
6.  根据主键值查找一条记录的步骤，均使用二分查找：
    1.  确定目录项记录的页
    2.  通过目录项记录的页查找到真实记录所在的页
    3.  在用户记录页中查找到记录
7.  聚簇索引（B+树），两个特点：
    -   使用记录主键值的大小进行记录和页的排序
    -   B+树的叶子节点存储的是完整的用户记录
    
8.  InnoDB会默认自动创建聚簇索引，同时在InnoDB中，聚簇索引就是数据的存储方式，也就是所谓的**索引即数据，数据即索引**
9.  二级索引，对非主键的其它列建立的索引，会形成一棵B+树，叶子节点存储的是**该列和主键**的值，目录项记录存储的是**该列值、主键值和页号**。排序根据该列的值排序，如为非唯一索引，则在列值相同时会根据主键值排序，保证目录项记录和用户记录的唯一性。
10.  根据二级索引查找时，因为存储的并非完全的用户记录，所以在找到记录时，要根据其主键值在聚簇索引进行二次查找操作，该过程称为**回表**
11.  联合索引，对多个列建立的索引，记录排序时先根据第一列排序，再根据第二列排序。本质也是二级索引，只建立一棵B+树
12.  B+树的根页面万年不动窝。
13.  一个页面最少存储2条记录
14.  MyISAM的索引方案，索引和数据分离，数据单独存在一个**数据文件**中，乱序存储，通过行号随机访问。索引存在一个**索引文件**中，为主键建立的索引也是B+树，但叶子节点存储的只是**主键值和行号**，需要根据行号在数据文件中查找相应记录。其主键索引实质也是二级索引，也需要进行一次回表操作。
15.  MyISAM的回表操作十分迅速（借助地址偏移量）。
16.  InnoDB中的索引即数据，数据即索引，而MyISAM中却是索引是索引，数据是数据。

# B+树索引的使用

1.  B+树的索引在时间和空间上都有代价。空间上，每建一个索引就建一棵B+树；时间上，每次对表的增删改，都可能会修改各个B+树索引记录的顺序，导致性能损耗。
2.  B+树索引适用的条件：
    -   全值匹配
    -   匹配左边的列（联合索引）
    -   匹配范围值
    -   精确匹配某一列并范围匹配另外一列（联合索引）
    -   用于排序（如联合索引，则顺序需一致，正逆序需一致）
    -   用于分组（如联合索引，则顺序需一致）
3.  适合建索引的情况：
    -   经常搜索、排序、分组的列
    -   基数大的列（列值越离散，越易于排序、查找）
    -   类型较小的列（占用空间越小，同一页中索引数越多）
    -   可以只对字符串值的前缀建立索引
    -   在表达式中索引值单独出现才会使用索引
4.  为了尽可能少的让聚簇索引发生页分裂和记录移位的情况，建议让主键拥有`AUTO_INCREMENT`属性
5.  为避免回表带来的性能损耗，建议在查询列表中只包含索引列的字段，如此便不需要回表，该操作称为**覆盖查询**。尽量使用覆盖查询。
6.  回表的代价，需要回表的记录越多，使用二级索引查找的性能就越低。因为使用查到的主键在聚簇索引查找时相对于大量记录而言是接近随机访问的，性能可能会低于全表扫描。MySQL有自带的查询优化器，如果需要回表的记录太多则会直接使用聚簇索引进行扫描。

# MySQL的数据目录

1.  数据目录和安装目录不一样，是专门用于存放数据的
2.  查看数据目录：`show variables like 'datadir'`
3.  每个数据库都对应一个数据目录下的子目录
4.  InnoDB用**表空间**来管理页，每个表空间都可以被划分为很多个页。表空间在物理上的概念就是一个个文件。
5.  表空间主要有**系统表空间**和**独立表空间**。MySQL5.5.7到MySQL5.6.6之间默认使用系统表空间（默认建立的文件名为`ibdata1`），即所有数据库的页都存在这一个文件中。独立表空间为每个表都有与其同名的`.ibd`文件。使用独立表空间可以很大程度上挣脱文件系统大小的限制。
6.  系统表空间和独立表空间可以在配置中设置，也可以手动相互转移
7.  MyISAM没有表空间，每个表都必定有`.MYD`和`.MYI`两个文件，`.MYD`代表数据文件，存放用户记录，`.MYI`代表索引文件，存放索引。
8.  文件系统对数据库的影响：
    +   数据库名称和表名称不得超过文件系统所允许的最大长度
    +   文件长度受文件系统最大长度限制
    +   特殊字符的处理（非拉丁字母和数字被映射为`@+编码值`）

# InnoDB的表空间

## 独立表空间

1.  **区（extent）**，用于管理页。连续64个页为一个区，默认占用1MB。每256个区归为一组。表空间是由若干个区或若干个组构成的。

2.  第一组中最开始的三个页面类型固定：`FSP_HDR`类型、`IBUF_BITMAP`类型、`INODE`类型。之后组的前两个页面类型固定：`XDES`类型、`BUF_BITMAP`类型。

3.  **碎片区（fragment）**，直属于表空间。在一个碎片区中，页的类型和目的是随意的。

4.  **段（segment）是若干完整的区和部分碎片区中零散的页的集合**。每个索引占两个段，叶子节点和非叶子节点占用两个不同的段。

5.  为某个段分配存储空间的策略：

    +   在刚开始向表中插入数据的时候，段从某个碎片区以单个页面为单位来分配存储空间
    +   当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间

6.  区大致可分为四类：

    +   空闲的区（FREE）
    +   有剩余空间的碎片区（FREE_FRAG）
    +   无剩余空间的碎片区（FULL_FRAG）
    +   附属于某个段的区（FSEG）

7.  `XDES Entry`结构（Extent Descriptor Entry），记录了区的一些信息和属性。。`XDES Entry`存放在表空间的每一个组的第一个页面中（第一组是`FSP_HDR`类型页，其余的是`XDES`类型页），存放256个`XDES Entry`结构，分别对应该组的256个区。

8.  `XDES Entry`之间通过`List Node`连接成一个`XDES Entry`链表

9.  直属于表空间的`XDES Entry`链表：

    +   `FREE`链表：把状态为`FREE`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表
    +   `FREE_FRAG`链表：把状态为`FREE_FRAG`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表。
    +   `FULL_FRAG`链表：把状态为`FULL_FRAG`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表。

10.  每个段有自己的三个`XDES Entry`链表：

     +   `FREE`链表：所有页面都是空闲的区对应的`XDES Entry`结构会被加入到这个链表。
     +   `NOT_FULL`链表：仍有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表。
     +   `FULL`链表：无空闲空间的区对应的`XDES Entry`结构会被加入到这个链表。

11.  每个链表都对应一个一个链表基节点（`List Base Node`），`List Base Node`结构中包含有链表长度、头结点和尾节点的位置，便于迅速定位某个链表。

12.  `INODE Entry`结构，用于记录段的属性。包含段的`FREE`链表、`NOT_FULL`链表、`FULL`链表的三个基节点

13.  直属于表空间的三个`FREE`链表、`FREE_FRAG`链表、`FULL_FRAG`链表的基节点，存储在表空间的第一个页面（`FSP_HDR`）的`file space header`中

14.  每个段对应的`INODE Entry`结构会集中存放到一个类型为`INODE`的页中，如果表空间中的段特别多，则会有多个`INODE Entry`结构，可能一个页放不下，这些`INODE`类型的页会组成两种列表：

     +   `SEG_INODES_FULL`链表，该链表中的`INODE`类型的页面都已经被`INODE Entry`结构填充满了，没空闲空间存放额外的`INODE Entry`了。

     +   `SEG_INODES_FREE`链表，该链表中的`INODE`类型的页面仍有空闲空间来存放

         `INODE Entry`结构。

15.  `SEG_INODES_FULL`链表和`SEG_INODES_FREE`链表的基节点，也存放在表空间的第一个页面（`FSP_HDR`）的`file space header`中。

16.  每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个`INODE Entry`结构与之对应，存储`INODE Entry`的大致过程就是这样的：

     +   先看看`SEG_INODES_FREE`链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的`INODE`类型的页面，然后把该`INODE Entry`结构放到该页面中。当该页面中无剩余空间时，就把该页放到`SEG_INODES_FULL`链表中。
     +   如果`SEG_INODES_FREE`链表为空，则需要从表空间的`FREE_FRAG`链表中申请一个页面，修改该页面的类型为`INODE`，把该页面放到`SEG_INODES_FREE`链表中，与此同时把该`INODE Entry`结构放入该页面。

17.  B+数索引的根索引页中的`PAGE_BTR_SEG_LEAF`和`PAGE_BTR_SEG_TOP`两个字段，分别对应一个`Segment Header`的结构（10个字节），用于记录对应的`INODE Entry`结构的地址，用于连接索引和段。

## 系统表空间

1.  关于数据的数据、为了保存数据而额外记录的信息，称为元数据。（如该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面）
2.  InnoDB中，记录元数据的表称为内部系统表，也称为数据字段，都是以`B+`树的形式保存在系统表空间的某些页面中。其中`SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS`四张表被称为基本系统表（basic system tables）
3.  基本系统表的元数据（聚簇索引和二级索引对应的B+树位置等）存储在系统表空间页号为7的`Data Dictionary Header`页面，类型为`SYS`，记录了数据字典的头部信息和整个InnoDB存储引擎一些全局属性。

<<<<<<< HEAD
# 单表访问原理
=======
# 单表访问
>>>>>>> ee7b04d169d2a3466a499ab47d6384163a3ade86

1.  `MySQL`执行查询语句的方式被称为**访问方法**或**访问类型**。同一条查询语句可能有多个查询方法。MySQL优化器会自动选择最优的访问方法

2.  访问方法有：

    +   const：通过主键或唯一二级索引来定位一条记录，最多一条记录需要回表

    +   ref：使用二级索引执行查询，有多条记录需要回表，必须等值查询；联合索引最左边的连续索引列不全是等值比较就不能算是ref

    +   ref_or_null：二级索引等值查询的同时查询该列为NULL的记录

    +   range：使用索引（聚簇索引或二级索引）进行范围匹配

    +   index：遍历二级索引的查询；如根据联合索引的第二列值查询第一列值，此时遍历二级索引的代价低于全表扫描

    +   all：全表扫描，直接扫描聚簇索引

    +   index merge：使用多个索引完成一次查询，有`Intersection`、`Union`、`Sort-Union`三种

3.  对于包含NULL值的处理要单独思考

4.  全表扫描一般情况下是先将聚簇索引的叶子节点记录全放入内存中，再进行扫描。空间不够时会借用磁盘暂存。

5.  在有AND或OR、为某个索引确定区间范围时，会把用不到查询用不到的索引搜索条件替换为**TRUE**

6.  一般情况下只能利用单个二级索引执行查询。

7.  当有`AND`连接的多个搜索条件时可能用到`Intersection`索引合并，当有`OR`连接的多个条件时可能用到`Union`或`Sort-Union`索引合并。

8.  使用`Intersection`索引合并查询的情况：

    +   二级索引列全是等值匹配，对于联合索引，在联合索引中的每个列都必须等值匹配
    +   当同时有主键和二级索引时，二级索引必须等值匹配，而**主键列可以范围匹配**。
    +   （优化器执行的根本依据）使用单个搜索条件从二级索引中查出的数据过多，需要回表的代价大于查询多个索引的代价

9.  只有**当根据二级索引查询出的结果是按照主键值排序的**才有可能使用`Intersection`索引合并。（方便取交集，无需排序，O(n)）

10.  使用`Union`索引合并的情况：

     +   二级索引列是等值匹配，对于联合索引，在联合索引中的每个列都必须等值匹配
     +   主键列可以范围匹配
     +   使用`Intersection`索引合并的搜索条件（搜索条件的某些部分使用`Intersection`索引合并的方式得到的主键集合和其他方式得到的主键集合取交集）
     +   （根本）在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过`Union`索引合并后进行访问的代价比全表扫描更小时。（OR的方式，需要全表扫描另一个过滤条件）

11.  `Sort-Union`索引合并：先按照二级索引记录的主键值进行排序，之后按照`Union`索引合并方式执行的查询方式。因为从二级索引获取的数量较少，所以排序的代价不会很高。该方式适用于如下这种情况：

     ```sql
     SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z';
     ```

# 表连接原理

1.  连接查询算法大致有三种：**嵌套循环连接（Nested-Loop Join）、基于索引优化的查询连接、基于块的嵌套循环连接（Block Nested-Loop Join）**
2.  嵌套循环连接：先使用单表访问的最优方法获取驱动表中的结果集，遍历结果集，从被驱动表中根据连接条件查出相应数据。被驱动表的访问次数取决于驱动表的结果集数量。相当于多个嵌套循环语句。
3.  嵌套循环连接中“从驱动表中获取匹配结果再访问被驱动表的方式”实际上是，**每获取到一条驱动表记录就立即去被驱动表中找匹配的记录**，将数据加入到结果集中，而不是先获取出全部的驱动表匹配记录。
4.  基于索引优化：使用索引优化的是**被驱动表**的访问方式（使用索引），提升访问速度，其访问次数不变，仍取决于驱动表的结果集数量。
5.  在连接查询中对**被驱动表**使用**主键值或者唯一二级索引列的值**进行等值查找的查询执行方式称之为：`eq_ref`。
6.  `join buffer`：执行连接查询前申请的一块固定大小的内存。大小可通过`join_buffer_size`变量设置，默认为256KB，最小为128字节。
7.  基于块的嵌套循环连接：加入了`join buffer`的嵌套循环连接算法。
8.  基于块的嵌套循环连接原理：先把若干条**驱动表**结果集中的记录装在`join buffer`中，然后扫描**被驱动表**，每一条被驱动表的记录一次性和`join buffer`中的多条驱动表记录做匹配。因为匹配的过程都是在内存中完成的，所以在被驱动表中数据非常多的时候，可以显著减少被驱动表的`I/O`代价。
9.  嵌套循环链接是将**被驱动表**的若干记录加载到内存中，而基于块的嵌套循环连接是将**驱动表**的若干记录加载到内存中。
10.  注意：驱动表的记录并不是所有列都会被放到`join buffer`中，只有查询列表中的列和过滤条件中的列才会被放到`join buffer`中。所以将尽可能少的列作为查询列表（最好不要`*`），如此才能在`join buffer`中放置更多记录。

# 问题

1.  为什么默认一页是16kb？
