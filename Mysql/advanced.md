# 字符集与比较规则

1.  Mysql 基本包含所有字符集

2.  GB2312和GBK是汉字字符集，占2个字节，GBK涵盖GB2312，是升级版

3.  Mysql 中的 utf8 字符集每个字符占3个字节，是阉割版的utf8字符集，真正的utf8是Mysql中的 utf8mb4，占四个字节

4.  查看字符集：

    ```sql
    show character set [like 'utf%']
    show charset [like 'utf%']
    ```

5.  比较规则包含有是否区分大小写、是否区分重音等，每个字符可有多个比较规则，且有一个默认的比较规则

6.  比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中

7.  查看比较规则：`show collation like 'utf8%'`

8.  字符集和比较规则有服务器级、数据库级、表级和列级四个级别，均可单独设置`character set [字符集]`，`collation set [比较规则]`

9.  从客户端发送请求时的字符集转换：

    -   客户端使用操作系统字符集编码，服务器对接收的字符串采用 `character_set_client` 代表的字符集进行解码，再使用`character_set_connection`字符集编码
    -   采用`character_set_connection`进行解码，再按照具体的列的字符集进行编码。若两者的字符集相同，则无需进行字符集的转换
    -   将从某个列获取到的字节串从该列使用的字符集转换为`character_set_results`代表的字符集后发送到客户端
    -   客户端使用操作系统的字符集进行解析

10.  最好统一设置`character_set_client`、`character_set_connection`和`character_set_results`这三个系统变量的值为同一个字符集：`set names utf8`



# InnoDB的记录格式

1.  **页**是InnoDB采用的磁盘与内存交互的基本单位，一般为16kb

2.  行格式有 Compact、Redundant、Dynamic、Compressed 四种。Redundant是Mysql5.0之前的老格式，Dynamic是Mysql 5.7之后的默认行格式

3.  查看、指定和修改行格式的语法如下：

    ```sql
    show variables like '%row_format';
    create table 表名 (列的信息) row_format=行格式名称
    alter table 表名 row_format=行格式名称
    ```

4.  Compact 行格式主要分为四个部分：变长字段长度列表、NULL值列表、记录头信息、记录的真实数据。

5.  Redundant行格式主要分为三个部分：字段长度偏移列表、记录头信息、记录的真实数据。

6.  变长字段长度列表。对列中的变长类型（varchar、varbinary、text、blob）字段的实际长度，按列顺序逆序排放。

7.  每个变长字段存储所占空间为1或2个字节。仅当该可变字段允许存储的**最大字节数**超过255，并且真实存储的字节数超过127字节，使用2个字节，否则使用1个字节存储。

8.  变长字符集（如utf8、gbk）下的定长类型（如char）的长度也会被纳入变长字段长度列表中。

9.  变长字段长度列表中只存储值为 **非NULL** 的列内容占用的长度，值为 NULL 的列的长度是不储存的

10.  NULL值列表仅存储允许为NULL的字段，逆序排列。每个字段占一位，仅有0和1。值为NULL时为1，非NULL时为0。实际按照整数个字节进行存储，不满一个字节（8位）时，前面自动用0补满。

11.  记录的真实数据除了自定义的列以外，还包含有隐藏列：`row_id`（作为主键的唯一标识id，占6字节）、`transaction_id`（事务id，占6字节）、`roll_pointer`（回滚指针，占7字节）。其中`row_id`只有当未设置主键且未设置Unique键时才会自动添加。

12.  Redundant行格式的字段长度偏移列表。所有列都会存长度信息，按照字段的偏移量来存长度。对NULL值处理时，将列对应的偏移量值的第一个比特位作为是否为NULL的依据，如果为1则是NULL，否则非NULL

13.  一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节（不算Text、Blob类型的字段）

14.  行溢出数据。数据量超过16kb则会出现行溢出，本页中只保留前`768`个字节和20个字节的溢出页面地址，剩下数据分散存储到其他页

15.  不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出

16.  相较Compact，Dynamic行格式则是将真实数据的所有字节都存储到其它页中，只在本页保留页地址；Compressed行格式在Dynamic的基础上对页采用压缩算法进行压缩

# InnoDB索引页结构

1.  页有各种不同的类型，用于存放数据的页称为索引页
2.  索引页分为7个部分：`file header`，`page header`，`Infimum + Supremum`，`User Records`，`Free Space`，`Page Directory`，`File Trailer`
3.  记录的记录头信息中，`delete_mask`表示是否删除，1为已删除。记录删除后被组成一个“垃圾链表”，所占用的空间可被重用
4.  每页会事先插入2条虚拟记录，表示最小记录和最大记录，存储在`Infimum + Supremum`部分中
5.  记录的记录头信息中，`next_record`属性表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。从而使页中的所有记录串联成一个`单链表`。
6.  规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）  
7.  `InnoDB`会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中，所以在一个页中根据主键查找记录是非常快的，分为两步：
    +   通过二分法确定该记录所在的槽
    +   通过记录的`next_record`属性遍历该槽所在的组中的各个记录
8.  每个组最后一条记录的头信息的`n_owned`记录该组的记录数，每个分组中的记录条数规定：对于最小记录所在的分组只能有**1**条记录，最大记录所在的分组拥有的记录条数只能是 **1~8** 条，剩下的分组中记录的条数范围只能在是 **4~8** 条
9.  `File Header`部分记录本页的信息，且每个数据页的`File Header`部分都有上一个和下一个页的编号，所以所有的数据页会组成一个`双链表`。该部分各类型的页都通用。
10.  数据页结构中的文件尾部 `File Trailer`， 校验同步是否成功的用途。有校验和、日志序列位置。该部分各类型的页都通用。

|         名称         |       中文名       | 占用空间大小 |         简单描述         |
| :------------------: | :----------------: | :----------: | :----------------------: |
|    `File Header`     |      文件头部      |   `38`字节   |     页的一些通用信息     |
|    `Page Header`     |      页面头部      |   `56`字节   |   数据页专有的一些信息   |
| `Infimum + Supremum` | 最小记录和最大记录 |   `26`字节   |     两个虚拟的行记录     |
|    `User Records`    |      用户记录      |    不确定    |   实际存储的行记录内容   |
|     `Free Space`     |      空闲空间      |    不确定    |    页中尚未使用的空间    |
|   `Page Directory`   |      页面目录      |    不确定    | 页中的某些记录的相对位置 |
|    `File Trailer`    |      文件尾部      |   `8`字节    |      校验页是否完整      |

# B+树索引

1.  数据页中的记录按照主键大小顺序排列，页之间的顺序也相同，下一页的记录的主键必大于上一页。
2.  当进行插入删除等操作时，不同页之间记录顺序需要调整，该过程称**为页分裂**
3.  对每个页建立索引目录，一页即一条记录，仅有主键和页号两个列，这种记录称为目录项记录，在记录头信息的`record_type`属性被记为1
4.  目录项记录储存在一页中，每条目录项指向用户记录的页。多个目录页又形成索引，目录。如此，多个层级，形成一棵B+树
5.  用户记录的页都在B+树的叶子节点上，非叶子节点都是目录项记录页。最底层称为第0层，一般不会超过4层。
6.  根据主键值查找一条记录的步骤，均使用二分查找：
    1.  确定目录项记录的页
    2.  通过目录项记录的页查找到真实记录所在的页
    3.  在用户记录页中查找到记录
7.  聚簇索引（B+树），两个特点：
    -   使用记录主键值的大小进行记录和页的排序
    -   B+树的叶子节点存储的是完整的用户记录
    
8.  InnoDB会默认自动创建聚簇索引，同时在InnoDB中，聚簇索引就是数据的存储方式，也就是所谓的**索引即数据，数据即索引**
9.  二级索引，对非主键的其它列建立的索引，会形成一棵B+树，叶子节点存储的是**该列和主键**的值，目录项记录存储的是**该列值、主键值和页号**。排序根据该列的值排序，如为非唯一索引，则在列值相同时会根据主键值排序，保证目录项记录和用户记录的唯一性。
10.  根据二级索引查找时，因为存储的并非完全的用户记录，所以在找到记录时，要根据其主键值在聚簇索引进行二次查找操作，该过程称为**回表**
11.  联合索引，对多个列建立的索引，记录排序时先根据第一列排序，再根据第二列排序。本质也是二级索引，只建立一棵B+树
12.  B+树的根页面万年不动窝。
13.  一个页面最少存储2条记录
14.  MyISAM的索引方案，索引和数据分离，数据单独存在一个**数据文件**中，乱序存储，通过行号随机访问。索引存在一个**索引文件**中，为主键建立的索引也是B+树，但叶子节点存储的只是**主键值和行号**，需要根据行号在数据文件中查找相应记录。其主键索引实质也是二级索引，也需要进行一次回表操作。
15.  MyISAM的回表操作十分迅速（借助地址偏移量）。
16.  InnoDB中的索引即数据，数据即索引，而MyISAM中却是索引是索引，数据是数据。



