## RPC

### 简述

RPC，即远程过程调用，平常我们调用本地的一些数据或函数直接调用就好了，但若想调用远程的数据，则需要经历网络的传输，比如Socket连接、IO、数据的解析等。而RPC就是帮助我们屏蔽底层的一些实现细节。

远程调用需要解决的问题：

1.  如何规定调用的语法？如：表示两个数相加用 + 还是add

2.  如何传递参数？如：怎么传递参数和顺序？参数间怎么分界？

3.  如何表示数据？

4.  如何知道一个服务端实现了哪些远程调用？

    >   假设服务端实现了多个远程调用，每个可能实现在不同的进程中，监听的端口也不一样，而且由于服务端都是自己实现的，不可能使用一个大家都公认的端口，而且有可能多个进程部署在一台机器上，大家需要抢占端口，为了防止冲突，往往使用随机端口，那客户端如何找到这些监听的端口呢？

5.  发生了错误、重传、丢包、性能等问题怎么办？

以上问题可以总结为：

-   协议约定问题
-   传输问题
-   服务发现问题



所有涉及远程数据传输的都可以算的上是RPC：

-   基于文本传输的：
    -   XML+SOAP
    -   JSON+RESTful
-   基于二进制传输的gRPC



一个合格的RPC框架需要做到的有：

-   序列化和反序列化
-   服务治理
-   网络传输

当然，RPC从最初的客户端服务器模式，最终演进到微服务。对于RPC框架的要求越来越多了，具体有以下几点要求：

1.  首先，传输性能很重要。因为服务之间的调用如此频繁了，还是二进制的越快越好。
2.  其次，跨语言很重要。因为服务多了，什么语言写成的都有，而且不同的场景适宜用不同的语言，不能一个语言走到底。
3.  最好既严谨又灵活，添加个字段不用重新编译和发布程序。
4.  最好既有服务发现，也有服务治理，就像Dubbo和Spring Cloud一样。



### GRPC

-   GRPC是一种二进制、性能好、跨语言、灵活的，同时可以进行服务治理的多快好省的RPC框架，唯一不足就是还是要写协议文件 `*.proto`。

-   GRPC序列化使用Protocol Buffers，网络传输使用HTTP 2.0，但其本身没有提供服务发现的机制，需要借助其他的组件，服务治理可以使用基于Envoy的ServiceMesh。



### 参考

-   趣谈网络协议