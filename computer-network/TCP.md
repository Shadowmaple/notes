## TCP

### TCP状态转换图

![](https://pic2.zhimg.com/80/v2-3d90dc70d9f11be118ac0301e0760d59_1440w.jpg)



### 三次握手

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

过程详细描述：

1.  首先客户端处于CLOSED状态，服务器处于LISTEN状态；
2.  客户端向服务器发送SYN报文，携带初始序列号seq=x，此时客户端处于SYN_SENT状态；
3.  服务器收到后，发送SYN+ACK报文，携带初始序列号seq=y，ack=x+1，此时服务器处于SYN_RCVD状态；
4.  客户端收到后，发送ACK报文，携带序列号x+1，ack=y+1，状态变为ESTABLISHED
5.  服务端收到ACK报文后，状态变为ESTABLISHED



三次握手的目的不仅在于确保一个连接的建立，还在于利用数据包的选项来承载特殊的信息，交换初始序列号ISN（Initial Sequence Number）

>   《TCP/IP详解卷一》中所注：
>
>   TCP的SYN段也能够承载应用数据，但是由于socket API不支持这种方式，所以很少被人所用。

所以可以说三次握手是可以传输数据的，但一般在第三次客户端ACK报文段传输可能会比较多，因此这时客户端已进入ESTLISED状态。但SYN段由于比较遭受到攻击，若是承载数据，那么服务端就要花费额外的内存去存储。



#### 初始序列号

初始序列号不是固定的，而是随机的，不同主机、同一主机在不同时刻都不相同

1.  避免网络中主机间序列号冲撞和重叠；
2.  避免同一个socket 四元组上一次滞留的报文进入下一次连接的数据流中；
3.  避免被第三方恶意推测出序列号，伪造报文；

Linux系统的序列号设置：

-   基于时钟的方案，对每一个连接为时钟设置随机的偏移量。
-   随机偏移量由socket四元组利用加密散列函数得到。散列函数的输入每隔5分钟就会改变一次。
-   在32位的初始序列号中，最高的8位是一个保密的序列号，剩余的则由散列函数生成。



### 四次挥手

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

**双方都可以主动关闭或被动关闭**，一般客户端作为主动关闭的乙方，服务端作为被动关闭的一方。

连接关闭过程：

1.  此时双方处于ESTABLISHED状态，假定主动关闭的一方是客户端，被动关闭的一方是服务端；
2.  客户端发送FIN报文，携带序列号seq=u，此时处于FIN_WAIT_1状态；
3.  服务端收到FIN报文，发送ACK报文，写到序列号seq=v，ack=u+1，此时处于CLOSE_WAIT状态；
4.  客户端收到ACK报文，状态变为FIN_WAIT_2；
5.  服务端在传送完最后的数据后，发送FIN+ACK报文，序列号seq为w，ack=u+1，此时状态变为LAST_ACK；
6.  客户端收到FIN+ACK后，发送ACK报文，携带序列号seq=u+1，ack=w+1，状态变为TIME_WAIT；
7.  服务端收到ACK报文后，正常关闭连接，状态变为CLOSED；
8.  客户端在等待2MSL后，正常关闭连接，状态变为CLOSED。



>   另外注明：客户端发起关闭连接可能是FIN+ACK，因为可能是接受服务端的数据后立马发起FIN，《TCP/IP卷一》上是这样标明的。



为什么不是一次挥手？
如果客户端只发送一次结束帧，那么可能有以下几种情况：

1. 服务器未收到帧，而服务器还处于可发送信息的“半连接”状态，那么仍旧会发送数据给客户端。而此时客户端已经“跑路”了，那么服务器的数据就不知道怎么发送了；而如果很快另起了一个客户端B，同样的端口，那么服务器的数据就会错误地发给客户端B。
2. 服务器收到了帧，如果客户端直接“跑路”了，而服务器还有工作没处理完，这就会强制停止工作
3. 服务器收到了帧，但客户端不知道服务器是否收到，因为怕还会有数据传回来，那么就会一直等，不停发送结束帧，而此时服务器已经关闭了，那么传送的帧就会错误。

为什么不是二次挥手？
1. 如果服务器还有工作未处理完，要等到处理完后才发送确认结束的“挥手”，那么时间会滞留过长，在此过程中，客户端会误以为未收到而持续发送结束帧
2. 如果服务器还有工作未处理完而直接“挥手”，客户端收到确认后直接关闭，那么服务器还是会陷入“半连接”状态

为什么不是三次挥手？
服务器要保证客户端已经收到了结束通知，而避免客户端一直等待服务器处理完工作。如果只挥手三次，那么服务器就不知道客户端是否收到了结束通知



#### 半关闭状态

TCP是全双工通信的，两端都可以同时向对方发送数据。半关闭状态是变为了单工状态，即一方不再进行数据发送，但还可以接受对方的数据传输。

一般出现在主动关闭的一方处于FIN_WAIT1，被动关闭的一方处于CLOSE_WAIT时，这时被动关闭方还可以传输未处理完的数据。当完成数据发送后，会发送FIN关闭连接，同时发出一个文件尾指示。

使用socket API中的`shutdown()`表示半关闭，应用程序自己关闭了数据传输，但仍希望接受对方的数据传输。使用`close()`则关闭双方的连接。

如果主动关闭方选择完全关闭，那可能就会跳过FIN_WAIT_2状态？？

#### TIME_WAIT

MSL（Maximum Segment Lifetime）称为最大报文生存时间，或最大段生存期。代表报文段在被丢弃前在网络中被允许存在的最长时间。

MSL数值的设置：

-   TCP报文段是以IP数据报的形式传输的，IP数据报拥有TTL字段和跳数限制字段，这两个字段限制了IP数据报的有效生存时间，即MSL。
-   RFC中默认为2分钟，但实际是可以修改的，Linux系统中可以修改参数`net.ipv4.tcp_fin_timeout`值为30秒-5分钟。

作用：保证双方正常关闭连接

按照规则，TIME_WAIT在等待2MSL时，其端口号不能被其它连接使用。但大多数系统都允许进程先对其进行绑定，但在2MSL有效期内，仍不能进行连接建立等操作。

TIME_WAIT是为了保证连接的正常关闭，那么若TIME_WAIT期间主动关闭的一方进程挂了/机器挂了，被动关闭的一方没收到ACK后重传FIN，这会发生什么？



### 同时打开和同时关闭连接

#### 同时打开连接

同时连接的情况首先要保证双方都要知晓对方的IP和Port。

1.  客户端和服务端几乎同时向对方发送SYN和初始序列号ISN，状态由CLOSE/LISTEN变为SYN_SENT
2.  双方收到SYN，但不是SYN+ACK
3.  向对方发送SYN+ACK，**状态由SYN_SENT变为SYN_RCVD**
4.  收到对方的SYN+ACK，状态变为ESTABLISHED

和正常的三次握手相比多了一次报文段

#### 同时关闭连接

1.  客户端和服务端同时向对方发起FIN，状态由ESTABLISHED变为FIN_WAIT1
2.  双方收到FIN，而不是ACK
3.  向对方**发送ACK**，**状态由FIN_WAIT1变为CLOSING**
4.  收到对方的ACK，**状态由CLOSING变为TIME_WAIT**
5.  等待2MSL后变为CLOSED状态

同时关闭使用到的报文段与正常关闭相同，均为4个，但报文段序列是交叉的。另外，使用到了额外的状态CLOSING。



### 异常断开

半开连接是指一方处于连接状态ESTABLISHED，另一方在未告知对方的情况下关闭或直接终止了连接，情况发生在主机崩溃的情况下（不是正常关机）。

假定异常断开的是客户端。

-   客户端**进程挂了**，客户端操作系统可以感知到，socket会优雅正常地关闭连接，即向服务端发送FIN？

-   客户端**机器挂了**：
    -   **没有重启**：服务端发送的数据会被丢弃，收不到ack，就会每隔一段时间进行重传，直到次数到达一个阈值，断开连接，并向对方发送一个RST报文，这个过程会持续几分钟到十来分钟。
    -   **迅速重启**：
        -   若客户端主机上**没有该进程的端口号**，针对不存在端口的连接请求，客户端内核就会**回复 RST 报文（reset），重置该TCP连接**；（UDP是回复ICMP端口不可达的消息）
        -   若客户端主机上**有该端口号**，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会**回复 RST 报文，重置该 TCP 连接。**
        -   总结：主机不会认识之前的连接，便**回复RST报文，告知对方终止释放，重置连接**

异常断开的情况被另一方发现的有两种：
-   发送数据时，会不断重传（重传计时器）
-   进行保活机制探测时，会不断发送探测报文（保活计时器）

保活机制可以设置开启，探测时发送一个空报文段或只包含字节，序列号为对方主机发送的ACK报文最大序号-1，因为这个序列号已经成功接收，不会对到达的报文造成影响。探测的响应报文也不包含任何有效的新的数据。比较省带宽和流量。

>   RFC那边不同意保活这个功能（理由看《卷一》），这个功能存在争议性，但最后大部分TCP的实现还是提供了，



### Q&A

Q1：**UDP 和 TCP 的区别**

A：

TCP：面向连接、字节流，传输可靠（保证数据正确性，保证数据顺序）、适合传输大量数据（流模式）、速度慢，建立连接需要开销较多（时间，系统资源），有拥塞控制（会自己限制自己的速度）和流量控制，只能一对一通信。

UDP：面向非连接、传输不可靠（尽最大努力交付）、用于传输少量数据(数据包模式)，可以一对一、一对多、多对一、多对多。

Q2：**为什么是三次握手（而不是两次？第三次作用是什么？）**

答：

**第三次握手是为了防止服务端因为之前滞留的连接建立请求（即第一次握手） 而建立连接，造成资源浪费**

解释：

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。

若只有两次握手，那么如果客户端之前曾发过的第一次握手，在网络中因为延迟阻塞了，但结果在第二次发送连接请求建立连接之后到达了服务器，那么服务器会再创建一个（多余的）连接。

采用三次握手的方式，第三次握手才真正建立连接，可以让服务端不建立多余的连接，节省资源。此时，即便客户端发的第一次握手请求被延迟发送到了服务端，服务端的响应之后，客户端也不会再发第三次握手了，所以不会建立多余连接。

**Q3：三次握手都有哪些用？**

+   确保连通性
+   得知对方的初始序列号（ISN，initial sequence number）
+   协定流量控制窗口大小和 MSL？？

**Q4：为什么要四次挥手？**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

……

**Q5：TCP四次挥手之后为什么要有 `TIME_WAIT`？**

`TIME_WAIT`等待的是2倍的 IP 数据报在网络中可存活的最大时间（2MSL）。理由：

-   保证双方正常关闭连接。确保最后一个确认报文（服务端发送的连接释放确认）能够到达。如果服务端没收到客户端发送来的确认报文，那么就会重新发送连接释放请求报文，客户端等待一段时间就是为了处理这种情况的发生。
-   等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

**Q6：TCP 如何保证“可靠”？**

TCP 保证数据可靠性的方式大致可以分为三类：

+   在数据包层面：校验和
+   在数据包传输层面：序列号、确认应答、超时重传、快重传
+   在流量控制层面：拥塞控制、流量控制

**Q7：TCP各个状态作用：**

-   CLOSE WAIT https://huoding.com/2016/01/19/488

-   TIME WAIT https://huoding.com/2013/12/31/316

**Q8：TCP 长连接和短连接有什么区别？**

TCP 短连接是指客户端与服务端连接后只进行一次读写就关闭连接，一般是客户端关闭。

而长连接则是指在进行完一次读写后不关闭连接，直到服务端压力过大则选择关闭一些长时间为进行读写的连接。

TCP 短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。

TCP 长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。

长短连接的区别就在于客户端和服务端选择的关闭策略不同，具体需要根据应用场景来选择合适的策略。



Q9：TCP为什么收到三个重复确认后要缩减拥塞窗口（快恢复）？理论上讲收到重复确认说明网络并没有拥塞

……



### 参考

-   [CS-Notes](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html)
-   [面试问题详解——TCP](https://leetcode-cn.com/circle/discuss/aqTOW4/)



