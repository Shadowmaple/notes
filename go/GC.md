# Golang GC

## 简述GC

普遍来说，GC有两类：

-   引用计数
-   追踪式回收

引用计数算法：

-   优点：简单，易实现
-   缺点：容易出现循环引用的问题，出现内存泄露。比如A引用B，B又引用A，那么A、B引用都不会为0，也就不会回收。

Golang 的GC属于追踪式的。

## v1.0 标记清除法

流程：

1.  STW
2.  标记阶段：标记所有可达和不可达的对象
3.  清除阶段：清除不可达对象
4.  停止STW

## v1.5 三色标记法&插入和删除写屏障

### 三色标记法

大体流程：

1.  所有对象标记为白色white
2.  从堆栈的根节点出发扫描，将可达的节点标记为灰色grey
3.  从灰色节点扫描，将可达的白色节点标记为灰色grey，原灰色节点标记为黑色black
4.  循环扫描灰色节点，直到所有无灰色节点
5.  将白色节点清除

扫描节点可以理解为BFS

颜色标记应该都是有集合的，标记为灰色就放入灰色集合

在GC准备阶段和清除阶段应该是都有STW的。

### 问题

单纯的三色标记法在实际使用中会出现一些问题，比如在GC扫描中，一个黑色对象引用了一个新创建的对象，那么因为黑色对象是不会再次被扫描的，所以最终这个新创建的白色对象会被清除。

在三色标记法中，以下两个条件是不希望发生的：

+   **条件1：一个白色对象被黑色对象引用（白色被挂在黑色下）**
+   **条件2： 灰色对象到其可达的白色对象的路径遭到破坏（灰色丢了该白色）**

当以上两个条件被**同时满足**时，就会出现对象错误丢失的情况。

例如：一个黑色对象引用了一个白色对象（条件1），但这个白色对象可以通过一个灰色对象到达（不满足条件2），那么不会出现问题；而若一个灰色对象删除一个白色对象的引用（条件2），但白色对象也没有被黑色对象引用（不满足条件1），那么这个白色对象会被清除，也不会出现问题。

### 强弱三色不变式

只要满足任意一个条件，都可以保证对象不会丢失，因此引出以下两种方式：

-   **强三色不变式**：不存在黑色对象引用到白色对象。即不允许黑色对象引用白色对象。

-   **弱三色不变式**：所有被黑色对象引用的白色对象都处于灰色保护状态。具体来说就是黑色对象可以引用白色对象，但同时白色对象可以从任一灰色对象抵达。

为了遵循上述的两个方式，Golang团队初步得到了两种屏障方式：插入写屏障，删除写屏障。

### 插入写屏障

PS：插入写屏障只在**堆**上启用，因为栈容量小更注重性能，函数调用弹出频繁使用。

**操作：被引用的对象会被标记为灰色**

满足强三色不变式，即不存在黑色对象引用白色对象。

伪代码：

```txt
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //1
  标记灰色(新下游对象ptr)   

  //2
  当前下游对象slot = 新下游对象ptr  				  
}
```

例如：

```txt
A.添加下游对象(nil, B)   // A之前没有下游，新添加一个下游对象B，B会被标记为灰色
A.添加下游对象(C, B)     // A将下游对象C更换为B，B会被标记为灰色
```

因为栈不会启用插入写屏障，由于可能存在白色对象被引用的情况，所以最后需要对栈重新进行扫描resan，这时为了对象不被丢失，会启动STW。

>   运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时**暂停程序、将所有栈对象标记为灰色并重新扫描**，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。

### 删除写屏障

**操作: 被删除的对象，如果为白色，则被标记为灰色。**

满足弱三色不变式，即保护灰色对象到白色对象的路径不会断。

伪代码：

```txt
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
    标记灰色(当前下游对象slot)     //slot为被删除对象，标记为灰色
  }

  //2
  当前下游对象slot = 新下游对象ptr
}
```

例如：

```
A.添加下游对象(B, nil)  // A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)    // A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)
```

缺点：回收精度低。可以看出一个被删除的对象，因为被标记了灰色，所以它最终是可以活过这一轮GC的，但会在下一轮中被清除掉。

至于为什么要标记为灰色，是要保证弱三色不变式，保证该对象到其它白色对象的路径不会被破坏。（当一个黑色对象引用该删除对象的下游对象时）

### 小结

插入写屏障和删除写屏障的短板：

+   插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
+   删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

## v1.8 混合写屏障

混合写屏障综合了插入和删除屏障的优点，在GC期间不需要STW。

操作：

1.  **首先优先扫描栈，将所有可达的全部标记为黑色（STW）**
2.  GC期间，任何在**栈**上创建的新对象，均为**黑色**
3.  被删除的对象标记为**灰色**
4.  被添加的对象标记为**灰色**

满足变形的弱三色不变式（？）

**屏障机制伪代码：**

```txt
添加下游对象(当前下游对象slot, 新下游对象ptr) {
  //1 
  标记灰色(当前下游对象slot) // 只要当前下游对象被移走，就标记灰色

  //2
  标记灰色(新下游对象ptr)

  //3
  当前下游对象slot = 新下游对象ptr
}
```

注意：

-   屏障技术是不在栈上应用的，因为要保证栈的运行效率。
-   栈上多添加了灰色对象还是会扫描的，栈只是不使用屏障技术，在GC期间还是和堆上一样扫描灰色对象。

## 总结

-   GoV1.0 标记清除法，整体过程需要启动STW，效率极低。

-   GoV1.5 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈（需要STW），效率较低。GC时间从几百ms降低到10ms以下。

-   GoV1.8 三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程不需要STW，效率较高。使用混合写屏障后，GC时间缩短到0.5ms内。

**注意：在GC准备阶段和最后的清除阶段都是有STW的，**并不代表使用混合写屏障之后就没有了STW。

## Q&A

Q1：混合写屏障中，栈上，一个黑色对象引用一个白色对象？白色会变为灰色吗？为什么？

如果白色对象是堆上的，且没断开引用，那么栈无论标不标记都无所谓；如果断开了引用，那么就是删除操作，会被标记为灰色。

其实我反倒觉得栈新引用一个白色对象是创建操作，那么会被标记为黑色。如过被标记为黑色，而这个对象在堆上引用了一个白色对象，那那个白色对象就不可达了？

？？



Q2：怎么通过一个对象，查找到下一个对象？值和指针查找的区别？

指针类型内存区域有部分

## Ref

-   主要：[Golang修养之路](https://www.kancloud.cn/aceld/golang/1958308#1___166)；[对应视频](https://www.bilibili.com/video/BV1wz4y1y7Kd?p=14&spm_id_from=pageDriver)
-   [码农桃花源](https://qcrao91.gitbook.io/go/gc/gc#7-you-le-gc-wei-shen-me-hai-hui-fa-sheng-nei-cun-xie-lu)
-   [Go语言设计与实现-垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)

