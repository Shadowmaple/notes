# Redis持久化

Redis持久化时是新开一个进程来持久化，而不是使用工作线程，也不是在redis进程新开一个线程

Redis数据库在进行写操作时到底做了哪些事，主要有下面五个过程：

1.  客户端向服务端发送写操作（数据在客户端的内存中）。
2.  数据库服务端接收到写请求的数据（数据在服务端的内存中）。
3.  服务端调用write这个系统调用，将数据往磁盘上写（数据在系统内存的缓冲区中）。
4.  操作系统将缓冲区中的数据转移到磁盘控制器上（数据在磁盘缓存中）。
5.  磁盘控制器将数据写到磁盘的物理介质中（数据真正落到磁盘上）。

## RDB持久化

保存的是快照，即某个时刻redis内存中的所有数据

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

父进程继续处理客户端请求，调用fork产生一个子进程，进行`copy on write`快照，即持久化的是子进程产生那一瞬间的数据版本，父进程修改数据时会复制一个新版本再修改（？？），内存占用不是立即增长到2倍，而是逐渐增长，小于2倍。

子进程创建时，其资源是父进程的拷贝，所以父进程的修改不会影响子进程。

而由于虚拟内存，同样的页表数据是共享的，指向同一片物理内存，所以内存使用率不会double；而随着父进程接受修改请求，内存使用率才会逐渐上升。



#### Copy or Write

>   fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会**把触发的异常的页复制一份**，于是父子进程各自持有独立的一份。



#### 优势

1.  方便备份
2.  恢复大量数据时较快
3.  RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘操作。

#### 劣势

1.  如果系统发生故障，将会丢失最后一次创建快照之后的数据。
2.  如果数据量很大，保存快照的时间会很长。



## AOF持久化

AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到AOF文件，以此达到记录数据库状态的目的。AOF文件其实可以认为是Redis写操作的日志记录文件。

>   注：不是快照也不是完全的写操作，而是类似于快照的命令。比如a自增100次，只会保存它最后的值

使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

|   选项   |         同步频率         |
| :------: | :----------------------: |
|  always  |     每个写命令都同步     |
| everysec |       每秒同步一次       |
|    no    | 让操作系统来决定何时同步 |

+   always 选项会严重减低服务器的性能；
+   everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
+   no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。



……

## 参考

https://blog.csdn.net/u011784767/article/details/76824822

