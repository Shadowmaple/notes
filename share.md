# 进程、线程和协程

## 进程

程序（program）：一个**二进制文件**，放置在存储媒介（如硬盘、光盘、软盘、磁带等）中，以物理文件的形式存在。

进程（process）：**运行中的程序**。程序被触发后，执行者的**权限与属性**、程序的代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个 PID。

**进程是资源分配的基本单位**

子进程：

+   由某个进程衍生出来的进程，拥有PID和PPID（Parent PID）

+   子进程会继承父进程的相关权限和属性
+   子进程依附于父进程而存在
+   一个父进程可拥有多个子进程

### 进程状态

| 状态                    | 说明                                                     |
| ----------------------- | -------------------------------------------------------- |
| R（running / runnable） | 正在执行或者可执行，此时进程位于执行队列中。             |
| S（sleeping）           | 休眠                                                     |
| Z（zombie）             | 僵死，进程已经终止但是尚未被其父进程获取信息。           |
| T（stopped）            | 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 |

### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（ID为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

>   [孤儿进程与僵尸进程](https://www.cnblogs.com/Anker/p/3271773.html)

### 进程切换



## 线程

**线程**（thread）：操作系统能够进行**运算调度的最小单位**。

+   线程包含在进程之中，从属于进程，是进程中的实际运作单位。
+   一个进程可以有多个线程，每条线程共同执行不同的任务，它们共享进程的资源。

>   浏览器是一个进程，浏览器进程里面又有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等

线程与进程的比较：

1.  资源：进程是资源分配的基本单位，但是线程不占有资源，线程可以访问同一进程的资源。
2.  调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3.  系统开销：
    +   创建销毁：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。
    +   切换：在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。（工厂、流水线）
4.  通信方面：进程通信需要借助 IPC（Interprocess communication），而线程间则可以直接通过读写同一进程中的数据进行通信。



![](https://raw.githubusercontent.com/Shadowmaple/mydocuments/master/images/blog/process_thread_coroutine.jpeg)



## 协程

协程（coroutine）是一种比线程更加轻量级的存在。

+   协程从属于线程，协程的调度发生在其所在的线程中
+   一个线程可拥有一个或多个协程
+   协程由程序控制，而非受系统内核管理。


因为协程的调度切换不是线程切换，而是由程序自身控制，避免了陷入内核级别的上下文切换造成的性能损失。（应用态vs内核态）

和多线程相比，线程数量越多，协程的性能优势就越明显。

协程在内存的花销，使用其所在的线程的内存，线程的内存可以供多个协程使用。



协程和线程的整体比较

| 比较的点 | 线程                             | 协程                                                         |
| :------- | :------------------------------- | :----------------------------------------------------------- |
| 存储     | 内核态的内存空间                 | 一般是线程提供的用户态内存空间                               |
| 切换操作 | 操作最终在内核层完成             | 应用层使用代码进行简单的现场保存和恢复即可                   |
| 任务调度 | 由内核实现，抢占方式，依赖各种锁 | 由用户态的实现的具体调度器进行，例如 go 协程的调度器         |
| 实现规范 | 按照现代操作系统规范实现         | 无统一规范。在应用层由开发者实现，高度自定义。比如只支持单线程的线程，不同的调度策略，等等 |

# 并发与并行

+   并行：多个任务在多个CPU上同时执行
+   并发：多个在单个CPU上交错执行

并行的实现需要多个CPU，多个进程可以在不同CPU上同时执行，互不干扰；而单个CPU只能实现顺序执行，最多达到伪并行的程度。

并发的重点在于架构，或者说是一种设计模式；而并行重在执行方式。

并发设计就是使多个任务可以在重叠的时间段内进行。由于CPU速度过快，几乎感受不到它的切换，从宏观上来说，它们是同时执行的，但实际上它们是在单个CPU上交错跳跃的。

