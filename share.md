# 进程、线程和协程

## 进程

程序（program）：一个**二进制文件**，放置在存储媒介（如硬盘、光盘、软盘、磁带等）中，以物理文件的形式存在。

进程（process）：**运行中的程序**。程序被触发后，执行者的**权限与属性**、程序的代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个 PID。

**进程是资源分配的基本单位**

子进程：

+   由某个进程衍生出来的进程，拥有PID和PPID（Parent PID）

+   子进程会继承父进程的相关权限和属性
+   子进程依附于父进程而存在
+   一个父进程可拥有多个子进程

### 进程状态

| 状态                    | 说明    |
| ----------------------- | --------------- |
| R（running / runnable） | 正在执行或者可执行，此时进程位于执行队列中|
| D（uninterruptible sleep）| 不可中断阻塞，通常为 IO 阻塞，不可被信号唤醒 |
| S（interruptible sleep） | 可中断阻塞，系统资源被其它进程占用，该进程正在等待某个事件完成，可被信号唤醒 |
| Z（zombie）    | 僵死，进程已经终止但是尚未被其父进程获取信息  |
| T（stopped）   | 结束，进程既可以被作业控制信号结束，也可能是正在被追踪 |

### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（ID为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

>   [孤儿进程与僵尸进程](https://www.cnblogs.com/Anker/p/3271773.html)

## 线程

**线程**（thread）：操作系统能够进行**运算调度的最小单位**。

+   线程包含在进程之中，从属于进程，是进程中的实际运作单位。
+   一个进程可以有多个线程，每条线程共同执行不同的任务，它们共享进程的资源。

>   浏览器是一个进程，浏览器进程里面又有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等

线程的上下文切换：保存一个线程的状态到内存，再回复另一个线程的状态，最后更新调度器的数据结构。

线程与进程的比较：

1.  资源：进程是资源分配的基本单位，但是线程不占有资源，线程可以访问同一进程的资源。
2.  调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3.  系统开销：
    +   创建销毁：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。
    +   切换：在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。（工厂、流水线）
4.  通信方面：进程通信需要借助 IPC（Interprocess communication），而线程间则可以直接通过读写同一进程中的数据进行通信。



![](https://raw.githubusercontent.com/Shadowmaple/mydocuments/master/images/blog/process_thread_coroutine.jpeg)



## 协程

协程（coroutine）是一种比线程更加轻量级的存在。

+   协程从属于线程，协程的调度发生在其所在的线程中
+   一个线程可拥有一个或多个协程
+   协程共享线程的内存
+   协程由程序控制，而非受系统内核管理。


因为协程的调度切换不是线程切换，而是由程序自身控制，避免了陷入内核级别的上下文切换造成的性能损失。（应用态vs内核态）

和多线程相比，线程数量越多，协程的性能优势就越明显。

### 协程和线程的整体比较

| 比较的点 | 线程                           | 协程                                                         |
| :------- | :----------------------------- | :----------------------------------------------------------- |
| 存储     | 内核态的内存空间               | 一般是线程提供的用户态内存空间                               |
| 切换操作 | 操作最终在内核层面完成         | 应用层使用代码进行简单的现场保存和恢复即可                   |
| 任务调度 | 由内核实现，抢占式，依赖各种锁 | 由用户态的实现的具体调度器进行，例如 go 协程的调度器         |
| 实现规范 | 按照现代操作系统规范实现       | 无统一规范。在应用层由开发者实现，高度自定义。比如只支持单线程的线程，不同的调度策略，等等 |

os线程和goroutine

1.  栈：线程都有一个固定大小的栈内存（通常为2MB），而goroutine则是具有一个可增长的栈内存（2KB — 1GB）
2.  调度：
    +   os线程由os内核来调度，由硬件时钟来定期触发：每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个叫调度器的内核函数，该函数暂停当前运行的线程，启动线程切换。
    +   Go有一个自己的调度器，该调度器是由特定的Go语言结构来触发的，比如`time.sleep`、通道阻塞、互斥操作等。

# 并发与并行

并发 (concurrent) 与并行 (parallellism) 是一对孪生兄弟，两者十分相似， 但却是不同的两个概念， 有明确的区别。加州大学伯克利分校的一篇技术报告给出了并发与并行的概念定义：

>   “并发”是在逻辑层面上的同时工作
>
>   “并行”是在物理层面上的同时工作

通俗解释：

+   并行：在同一时间内，多个任务在多个CPU上同时执行
+   并发：在重叠的时间内，多个任务在单个CPU上交错执行

并行的实现需要多个CPU，多个进程可以在不同CPU上同时执行，互不干扰；而单个CPU只能实现顺序的串行，最多达到伪并行的程度。

并发的反义是顺序，并行的反义是串行。并发和并行并不是互斥概念，并发的重点在于架构，或者说是一种设计模式；而并行重在执行方式。

并发设计的目的就是使多个任务可以在重叠的时间段内“同时”进行，以充分利用系统资源，提高效率。由于CPU速度过快，几乎感受不到它的切换，从宏观上来说，它们是同时执行的，但实际上它们是在单个CPU上交错跳跃的。

并发和顺序执行的区别：顺序执行是指多个任务挨个执行，强调执行的先后顺序，中间不发生切换；而并发在多个任务间来回交错执行。如此，并发能够充分利用系统闲置的资源，效率更高。



# 参考文档

+   [进程切换与线程切换的区别](https://segmentfault.com/a/1190000019750164)